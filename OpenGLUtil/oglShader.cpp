#include "oglRely.h"
#include "oglException.h"
#include "oglShader.h"

namespace oglu
{
namespace detail
{

_oglShader::_oglShader(const ShaderType type, const string & txt) : shaderType(type), src(txt)
{
    auto ptr = txt.c_str();
    shaderID = glCreateShader(GLenum(type));
    glShaderSource(shaderID, 1, &ptr, NULL);
}

_oglShader::~_oglShader()
{
    if (shaderID != GL_INVALID_INDEX)
        glDeleteShader(shaderID);
}

void _oglShader::compile()
{
    glCompileShader(shaderID);

    GLint result;

    glGetShaderiv(shaderID, GL_COMPILE_STATUS, &result);
    if (!result)
    {
        GLsizei len = 0;
        glGetShaderiv(shaderID, GL_INFO_LOG_LENGTH, &len);
        string logstr((size_t)len, '\0');
        glGetShaderInfoLog(shaderID, len, &len, logstr.data());
        const auto logdat = str::to_u16string(logstr.c_str());
        oglLog().warning(u"Compile shader failed:\n{}\n", logdat);
        COMMON_THROW(OGLException, OGLException::GLComponent::Compiler, L"Compile shader failed", logdat);
    }
}

}

oglShader __cdecl oglShader::loadFromFile(const ShaderType type, const fs::path& path)
{
    using namespace common::file;
    string txt = FileObject::OpenThrow(path, OpenFlag::BINARY | OpenFlag::READ).ReadAllText();
    oglShader shader(type, txt);
    return shader;
}


vector<oglShader> __cdecl oglShader::loadFromFiles(const u16string& fname)
{
    static pair<u16string, ShaderType> types[] =
    {
        { u".vert",ShaderType::Vertex },
        { u".frag",ShaderType::Fragment },
        { u".geom",ShaderType::Geometry },
        { u".comp",ShaderType::Compute },
        { u".tscl",ShaderType::TessCtrl },
        { u".tsev",ShaderType::TessEval }
    };
    vector<oglShader> shaders;
    for (const auto& type : types)
    {
        fs::path fpath = fname + type.first;
        try
        {
            auto shader = loadFromFile(type.second, fpath);
            shaders.push_back(shader);
        }
        catch (const FileException& fe)
        {
            oglLog().warning(u"skip loading {} due to Exception[{}]", fpath.u16string(), fe.message);
        }
    }
    return shaders;
}

constexpr static auto OGLU_DEFS = R"(
#if defined(OGLU_VERT)
#   define GLVARY out
#elif defined(OGLU_FRAG)
#   define GLVARY in
#else
#   define GLVARY 
#endif
)";
constexpr static auto OGLU_EXT_STR = "\r\n\r\n\r\n//Below generated by OpenGLUtil\r\n";
constexpr static auto OGLU_EXT_STR2 = "\r\n//Above generated by OpenGLUtil\r\n\r\n";

static const map<uint64_t, ShaderPropertyType> ShaderPropertyTypeMap = 
{
    { "VEC"_hash,    ShaderPropertyType::Vector   },
    { "MAT"_hash,    ShaderPropertyType::Matrix   },
    { "COLOR"_hash,  ShaderPropertyType::Color    },
    { "BOOL"_hash,   ShaderPropertyType::Bool     },
    { "INT"_hash,    ShaderPropertyType::Int      },
    { "UINT"_hash,   ShaderPropertyType::Uint     },
    { "RANGE"_hash,  ShaderPropertyType::Range    },
    { "FLOAT"_hash,  ShaderPropertyType::Float    }
};

static std::optional<ShaderExtProperty> ParseExtProperty(const string_view& line)
{
    auto parts = str::Split(line, '|', true);
    if (parts.size() < 2)
        return {};
    if (auto type = common::container::FindInMap(ShaderPropertyTypeMap, hash_(parts[1])))
    {
        if (parts.size() == 2)
            return ShaderExtProperty(string(parts[0]), *type);
        string description(parts[2]);
        try
        {
            std::any data;
            if(parts.size() > 3)
                switch (*type)
                {
                case ShaderPropertyType::Float:
                case ShaderPropertyType::Range:
                    data = std::make_pair(std::stof((string)parts[3]), std::stof((string)parts[4])); break;
                case ShaderPropertyType::Int:
                    data = std::make_pair(std::stoi((string)parts[3]), std::stoi((string)parts[4])); break;
                case ShaderPropertyType::Uint:
                    data = std::make_pair((uint32_t)std::stoul((string)parts[3]), (uint32_t)std::stoul((string)parts[4])); break;
                }
            return ShaderExtProperty(string(parts[0]), *type, description, data);
        }
        catch (...)
        {
            COMMON_THROW(OGLException, OGLException::GLComponent::OGLU, L"Error in parsing property", string(line));
        }
    }
    else
        return {};
}

vector<oglShader> __cdecl oglShader::loadFromExSrc(const string& src, set<ShaderExtProperty, std::less<>>& properties)
{
    vector<oglShader> shaders;
    vector<string_view> params;
    string_view partVersion;
    uint32_t lineCnt = 0, lineNum = 0;
    str::SplitAndDo(src, [](const char ch) { return ch == '\r' || ch == '\n'; },
        [&](const char *pos, const size_t len) 
        {
            lineCnt++;
            string_view config(pos, len);
            if (str::IsBeginWith(config, "#version"))
            {
                partVersion = string_view(src.c_str(), pos - src.c_str() + len);
                lineNum = lineCnt + 1;
                return;
            }
            if (str::IsBeginWith(config, "//@@##"))
            {
                config.remove_prefix(6);
                if (auto prop = ParseExtProperty(config))
                    properties.insert(prop.value());
                return;
            }
            if (!str::IsBeginWith(config, "//@@$$"))
                return;
            config.remove_prefix(6);
            str::Split(config, '|', params, false);
        }, false);
    if (params.empty())
        COMMON_THROW(BaseException, L"Invalid shader source");
    string_view partOther(src.c_str() + partVersion.size(), src.size() - partVersion.size());
    string lineFix = "#line " + std::to_string(lineNum);
    for (const auto& sv : params)
    {
        ShaderType shaderType;
        const char *scopeDef = nullptr;
        switch (hash_(sv))
        {
        case "VERT"_hash:
            {
                shaderType = ShaderType::Vertex;
                scopeDef = "#define OGLU_VERT\r\n";
            } break;
        case "FRAG"_hash:
            {
                shaderType = ShaderType::Fragment;
                scopeDef = "#define OGLU_FRAG\r\n";
            } break;
        case "GEOM"_hash:
            {
                shaderType = ShaderType::Geometry;
                scopeDef = "#define OGLU_GEOM\r\n";
            } break;
        default:
            continue;
        }
        oglShader shader(shaderType, str::Concat<char>(partVersion, OGLU_EXT_STR, scopeDef, OGLU_DEFS, OGLU_EXT_STR2, lineFix, partOther));
        shaders.push_back(shader);
    }
    return shaders;
}

}
